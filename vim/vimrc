"                         ███████████████████████████
"                         ███████▀▀▀░░░░░░░▀▀▀███████
"                         ████▀░░░░░░░░░░░░░░░░░▀████
"                         ███│░░░░░░░░░░░░░░░░░░░│███
"                         ██▌│░░░░░░░░░░░░░░░░░░░│▐██
"                         ██░└┐░░░░░░░░░░░░░░░░░┌┘░██
"                         ██░░└┐░░░░░░░░░░░░░░░┌┘░░██
"                         ██░░┌┘▄▄▄▄▄░░░░░▄▄▄▄▄└┐░░██
"                         ██▌░│██████▌░░░▐██████│░▐██
"                         ███░│▐███▀▀░░▄░░▀▀███▌│░███
"                         ██▀─┘░░░░░░░▐█▌░░░░░░░└─▀██
"                         ██▄░░░▄▄▄▓░░▀█▀░░▓▄▄▄░░░▄██
"                         ████▄─┘██▌░░░░░░░▐██└─▄████
"                         █████░░▐█─┬┬┬┬┬┬┬─█▌░░█████
"                         ████▌░░░▀┬┼┼┼┼┼┼┼┬▀░░░▐████
"                         █████▄░░░└┴┴┴┴┴┴┴┘░░░▄█████
"                         ███████▄░░░░░░░░░░░▄███████
"                         ██████████▄▄▄▄▄▄▄██████████
"                         ███████████████████████████
"
"                                   Welcome!
"
" Thanks:
"  Tim Pope
"  Gmarik
"  Mislav Marohnić
"  Other

" IMPORTANT FOR CANCELLING/ABORTING GIT COMMIT
" Always use `:cq`.

if has('vim_starting')
  set nocompatible               " Be iMproved
endif

" VIM-PLUG

call plug#begin('~/.vim/plugged')

" SNIPMATE && SIPPESTS DEPENDENCIES
Plug 'MarcWeber/vim-addon-mw-utils' "Dependency of vim-sinpmate
Plug 'tomtom/tlib_vim' "Dependency of vim-sinpmate
Plug 'garbas/vim-snipmate'

Plug 'SirVer/ultisnips' | Plug 'honza/vim-snippets'
Plug 'Valloric/YouCompleteMe', { 'do': './install.sh' }

" LANGUAGES
Plug 'sheerun/vim-polyglot'

" RUBY
Plug 'sunaku/vim-ruby-minitest'
Plug 'thoughtbot/vim-rspec'
Plug 'ecomba/vim-ruby-refactoring'

" JAVASCRIPT
Plug 'jelera/vim-javascript-syntax'

" TPOPE
Plug 'tpope/vim-rails'
Plug 'tpope/vim-rake'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-rhubarb'
Plug 'tpope/vim-markdown'
Plug 'tpope/vim-endwise'
Plug 'tpope/vim-git'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-bundler'
Plug 'tpope/vim-dispatch'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-sleuth'

" Dependent on 'tpope/vim-fugitive'
Plug 'junegunn/gv.vim'

" COLORSCHEME
Plug 'altercation/vim-colors-solarized'
Plug 'chriskempson/vim-tomorrow-theme'
Plug 'w0ng/vim-hybrid'
Plug 'ajh17/Spacegray.vim'
Plug 'yosiat/oceanic-next-vim'
Plug 'nanotech/jellybeans.vim'
Plug 'tomasr/molokai'
Plug 'KabbAmine/yowish.vim'
Plug 'rakr/vim-one'
Plug 'chriskempson/base16-vim'
Plug 'joshdick/onedark.vim'
Plug 'morhetz/gruvbox'
Plug 'jnurmine/Zenburn'

" ENHANCEMENT
Plug 'airblade/vim-gitgutter'
Plug 'ntpeters/vim-better-whitespace'
Plug 'ngmy/vim-rubocop'
Plug 'janko-m/vim-test'
Plug 'terryma/vim-expand-region'
Plug 'Raimondi/delimitMate'
Plug 'google/vim-searchindex'
Plug 'wincent/terminus'
Plug 'vim-scripts/CSApprox'
Plug 'xolox/vim-misc'
Plug 'xolox/vim-session'

" PRODUCTIVITY
Plug 'AndrewRadev/splitjoin.vim'
Plug 'ctrlpvim/ctrlp.vim'
Plug 'ivalkeen/vim-ctrlp-tjump'
Plug 'tpope/vim-commentary'
Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' }
Plug 'Xuyuanp/nerdtree-git-plugin'
Plug 'ervandew/supertab'
Plug 'majutsushi/tagbar', { 'on': 'TagbarToggle' }
Plug 'easymotion/vim-easymotion'
Plug 'mileszs/ack.vim', { 'on': 'Ack' }
Plug 'szw/vim-maximizer'
Plug 'junegunn/vim-easy-align'
Plug 'maxbrunsfeld/vim-yankstack'
Plug 'dkprice/vim-easygrep'
Plug 'wsdjeg/FlyGrep.vim'
Plug 'rhysd/clever-f.vim'
Plug 'terryma/vim-multiple-cursors'
Plug 'tpope/vim-repeat'
Plug 'dbmrq/vim-ditto'
Plug 'wellle/targets.vim'
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
Plug 'junegunn/fzf.vim'
Plug 'mbbill/undotree'
Plug 'arthurxavierx/vim-caser'
Plug 'vim-scripts/grep.vim'

let g:make = 'gmake'
if exists('make')
  let g:make = 'make'
endif

Plug 'Shougo/vimproc.vim', { 'do': g:make }

" FUN
Plug 'chrisbra/unicode.vim', { 'on': ['<plug>(UnicodeComplete)', '<plug>(UnicodeGA)', 'UnicodeTable'] }

" ASYNCHRONOUS
Plug 'thinca/vim-quickrun' " Ruby
Plug 'w0rp/ale'

" EXTRA
Plug 'lifepillar/vim-cheat40'
Plug 'chrisbra/csv.vim'

call plug#end()


if has('nvim')
  runtime! macros/matchit.vim
else
  " VIM HAS ITS VERY OWN'S 'ADD-PACKAGE' FEATURE:
  " This plugin makes the '%' command jump to matching HTML tags, if/else/endif in Vim scripts, etc.
  packadd! matchit
endif

let no_buffers_menu=1
" COLORSHEME SETTINGS
if has('gui_running')
  if has("gui_mac") || has("gui_macvim")
    set guifont=Menlo:h15
    let g:onedark_terminal_italics = 1 " I love italic for comments
    colorscheme onedark
  endif
else
  colorscheme hybrid
  let g:CSApprox_loaded = 1

  if $COLORTERM == 'gnome-terminal'
    set term=gnome-256color
  else
    if $TERM == 'xterm'
      set term=xterm-256color
    endif
  endif
endif

" BASIC SETUP
syntax enable
set number                        " show line numbers
set ruler                         " show the cursor position all the time
set title                         " show file in titlebar
set encoding=utf-8                " set default encoding to UTF-8
set history=50                    " keep 50 lines of command line history
set mouse=a                       " automatically enable mouse usage
set mousehide                     " hide the mouse cursor while typing
set textwidth=80
set showcmd                       " display incomplete commands
set wildmenu                      " visual autocomplete for command menu
set ttyfast                       " faster redrawing.
set lazyredraw                    " don't redraw while executing macros (good performance config)
set showmatch                     " show matching brackets
set showmode                      " show current mode in command-line.
set matchtime=2                   " show matching bracket for 0.2 seconds
set autoindent                    " always set auto indenting on
set display=lastline              " show as much as possible of the last line.
set scrolloff=2                   " minimum lines to keep above and below cursor
set hidden                        " switch between buffers without having to save first.
set foldenable                    " auto fold code
set pastetoggle=<F2>
set confirm                       " get a dialog when :q, :w, or :wq fails
set cursorline                    " find the current line quickly.
set wrapscan                      " searches wrap around end-of-file
set bomb
set binary
set synmaxcol=256                 "  This helps to avoid very slow redrawing for long lines

" WHITESPACE
set nowrap                        " don't wrap text
set tabstop=2                     " tab spacing
set expandtab                     " use spaces instead of tabs
set softtabstop=2                 " unify
set shiftwidth=2                  " indent/outdent by 2 columns
set smarttab                      " use tabs at the start of a line, spaces elsewhere
set backspace=indent,eol,start    " backspace through everything in insert mode
set list                          " show invisible characters
set nojoinspaces                  " Use only 1 space after "." when joining lines, not 2

" AUTO-RELOAD BUFFERS WHEN FILE CHANGED ON DISK
set autoread

" DISABLE SWAP FILES; SYSTEMS DON'T CRASH THAT OFTEN THESE DAYS
set updatecount=0

set showbreak=↪\

" SEARCHING
set hlsearch                      " highlight matches
set incsearch                     " incremental searching
set ignorecase                    " searches are case insensitive...
set smartcase                     " unless they contain at least one capital letter
set gdefault                      " have :s///g flag by default on

" TIME OUT ON KEY CODES BUT NOT MAPPINGS. BASICALLY THIS MAKES TERMINAL VIM WORK SANELY.
set notimeout
set ttimeout
set ttimeoutlen=100

" TAB COMPLETION
set wildmode=list:longest,list:full

" DISABLE OUTPUT AND VCS FILES
set wildignore+=*.o,*.out,*.obj,.git,*.rbc,*.rbo,*.class,.svn,*.gem,tags,.fugitiveblame

" DISABLE ARCHIVE FILES
set wildignore+=*.zip,*.tar.gz,*.tar.bz2,*.rar,*.tar.xz

" IGNORE BUNDLER AND SASS CACHE
set wildignore+=*/vendor/gems/*,*/vendor/cache/*,*/.bundle/*,*/.sass-cache/*

" IGNORE RAILS TEMPORARY ASSET CACHES
set wildignore+=*/tmp/*,*/solr/*,*/coverage/*,*/features/*,*/public/uploads/*

" DISABLE TEMP AND BACKUP FILES
set wildignore+=*.swp,*~,._*,tags

" BACKUP AND SWAP FILES
set nobackup                      " turn backup off, since most stuff is in SVN, Git etc anyway...
set nowb                          " no writebackup
set noswapfile

set fileformats=unix,dos,mac

" OPEN NEW SPLIT PANES TO RIGHT AND BOTTOM, WHICH FEELS MORE NATURAL
set splitright
set splitbelow

" MAC'S OPTION KEY FOR YANKRING
if has('gui_running')
  set macmeta
endif

" AUTOCOMPLETE WITH DICTIONARY WORDS WHEN SPELL CHECK IS ON
set complete+=kspell

" ALWAYS USE VERTICAL DIFFS
set diffopt+=vertical

" TENDERLOVE'S SETTINGS
set suffixesadd=.rb
set path+=lib/**,test/**
set kp=ri " Use ri for help
set exrc
set secure

" session management
let g:session_directory = "~/.vim/session"
let g:session_autoload = "no"
let g:session_autosave = "no"
let g:session_command_aliases = 1

" TENDERLOVE'S SETTINGS
" Add stdlib of environment's ruby to path
let g:stdlib = system('ruby --disable-gems -rrbconfig -e"print RbConfig::CONFIG[\"rubylibdir\"]"')
let &path .= "," . stdlib
let g:ruby_path = &path

" TENDERLOVE'S SETTINGS
if has("terminal")
  map <Leader>tt :terminal ++close<cr>
  tnoremap <Esc> <C-W>N
endif

set tags+=.git/tags

" INDICATOR CHARS
if has('multi_byte') && &encoding ==# 'utf-8'
  let &listchars = 'tab:▸ ,extends:❯,precedes:❮,nbsp:±'
else
  let &listchars = 'tab:> ,extends:>,precedes:<,nbsp:.'
endif

if has("statusline") && !&cp
  set laststatus=2              " always show the status bar
  set statusline=%f\ %m\ %r     " filename, modified, readonly
  set statusline+=%=            " switch to the right side
  set statusline+=\ %l/%L[%p%%] " current line/total lines
  set statusline+=\ %3v         " current column
  set statusline+=\ %Y\ %{fugitive#head()}
endif

let g:mapleader = ","

" CTRLP SETTINGS
let g:ctrlp_use_caching       = 0
let g:ctrlp_working_path_mode = 0

" Default to filename searches - so that appctrl will find application
" controller
let g:ctrlp_by_filename = 1

" Don't jump to already open window. This is annoying if you are maintaining
" several Tab workspaces and want to open two windows into the same file.
let g:ctrlp_switch_buffer = 0

" Idea from : http://www.charlietanksley.net/blog/blog/2011/10/18/vim-navigation-with-lustyexplorer-and-lustyjuggler/
" Open CtrlP starting from a particular path, making it much
" more likely to find the correct thing first. mnemonic 'jump to [something]'
map ,ja :CtrlP app/assets<CR>
map ,jm :CtrlP app/models<CR>
map ,jc :CtrlP app/controllers<CR>
map ,jv :CtrlP app/views<CR>
map ,jh :CtrlP app/helpers<CR>
map ,jl :CtrlP lib<CR>
map ,jp :CtrlP public<CR>
map ,js :CtrlP app/services<CR>
map ,jf :CtrlP test/fixtures<CR>
map ,jd :CtrlP db<CR>
map ,jC :CtrlP config<CR>
map ,je :CtrlP config/environments<CR>
map ,jV :CtrlP vendor<CR>
map ,jF :CtrlP factories<CR>
map ,jT :CtrlP test<CR>

"Cmd-Shift-(M)ethod - jump to a method (tag in current file)
"Ctrl-m is not good - it overrides behavior of Enter
nnoremap <silent> <D-M> :CtrlPBufTag<CR>

" TREAT <li> AND <p> TAGS LIKE THE BLOCK TAGS THEY ARE
let g:html_indent_tags = 'li\|p'

" ALLOWS CURSOR CPANGE IN TMUX MODE
if exists('$TMUX')
  let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
  let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
else
  let &t_SI = "\<Esc>]50;CursorShape=1\x7"
  let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif

" SNIPPETS ARE ACTIVATED BY SHIFT+TAB
let g:snippetsEmu_key = "<S-Tab>"

" NERDTREE SETTINGS
let g:NERDTreeHijackNetrw=1
let NERDTreeMinimalUI = 1
let NERDTreeDirArrows = 1
let g:NERDTreeWinSize = 30
let g:NERDTreeChDirMode=2
let g:NERDTreeIgnore=['\.rbc$', '\~$', '\.pyc$', '\.db$', '\.sqlite$', '__pycache__']
let g:NERDTreeSortOrder=['^__\.py$', '\/$', '*', '\.swp$', '\.bak$', '\~$']
let g:NERDTreeShowBookmarks=1
let g:NERDTreeMapOpenInTabSilent = '<RightMouse>'

" grep.vim
nnoremap <silent> <leader>f :Rgrep<CR>
let Grep_Default_Options = '-IR'
let Grep_Skip_Files = '*.log *.db'
let Grep_Skip_Dirs = '.git node_modules'

"VIM-TEST PLUGIN SETTINGS
let test#strategy = "iterm"

" Exclude Javascript files in :Rtags via rails.vim due to warnings when parsing
let g:Tlist_Ctags_Cmd="ctags --exclude='*.js'"

" MAKE YCM COMPATIBLE WITH ULTISNIPS (USING SUPERTAB)
let g:ycm_key_list_select_completion = ['<C-j>', '<Down>']
let g:ycm_key_list_previous_completion = ['<C-k>', '<Up>']
let g:SuperTabDefaultCompletionType = '<C-n>'

let g:ycm_semantic_triggers =  {
      \   'c' : ['->', '.'],
      \   'objc' : ['->', '.', 're!\[[_a-zA-Z]+\w*\s', 're!^\s*[^\W\d]\w*\s',
      \             're!\[.*\]\s'],
      \   'ocaml' : ['.', '#'],
      \   'cpp,cuda,objcpp' : ['->', '.', '::'],
      \   'perl' : ['->'],
      \   'php' : ['->', '::'],
      \   'cs,java,javascript,typescript,d,python,perl6,scala,vb,elixir,go' : ['.'],
      \   'ruby' : ['.', '::'],
      \   'lua' : ['.', ':'],
      \   'erlang' : [':'],
      \ }

" Better key bindings for UltiSnipsExpandTrigger
let g:UltiSnipsExpandTrigger = "<tab>"
let g:UltiSnipsJumpForwardTrigger="<c-b>"
let g:UltiSnipsJumpBackwardTrigger="<c-z>"
let g:UltiSnipsEditSplit="vertical"

" The silver searcher (Faster than the ack)
" Invoke ag using ack.vim
if executable("ag")
  " Use Ag over grep
  set grepprg=ag\ --nogroup\ --nocolor

  let g:ackprg = 'ag --vimgrep'
  let g:agprg="ag --column"

  let g:ctrlp_user_command =
        \ 'ag %s --files-with-matches -g "" --ignore "\.git$\|\.hg$\|\.svn$"'

  " ag is fast enough that CtrlP doesn't need to cache
  let g:ctrlp_use_caching = 0
else
  " Fall back to using git ls-files if Ag is not available
  let g:ctrlp_custom_ignore = '\.git$\|\.hg$\|\.svn$'
  let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files . --cached --exclude-standard --others']
endif

" Every time you open a git object using fugitive it creates a new buffer.
" This means that your buffer listing can quickly become swamped with
" fugitive buffers. This prevents this from becomming an issue:
autocmd BufReadPost fugitive://* set bufhidden=delete

"" The PC is fast enough, do syntax highlight syncing from start unless 200 lines
augroup vimrc-sync-fromstart
  autocmd!
  autocmd BufEnter * :syntax sync maxlines=200
augroup END

"" Remember cursor position
augroup vimrc-remember-cursor-position
  autocmd!
  autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif
augroup END

let g:github_enterprise_urls = ['https://github.com']

" Turn off default key mappings
let g:multi_cursor_use_default_mapping=0

" Ctrl-n, Ctrl-p, Ctrl-x, and <Esc> are mapped in the special multicursor
" mode once you've added at least one virtual cursor to the buffer
let g:multi_cursor_next_key='<C-n>'
let g:multi_cursor_prev_key='<C-p>'
let g:multi_cursor_skip_key='<C-x>'
let g:multi_cursor_quit_key='<Esc>'

" Time limit of each task in seconds for vim-plug
let g:plug_timeout = 100

" RSpec.vim mappings
map <Leader>t :call RunCurrentSpecFile()<CR>
map <Leader>s :call RunNearestSpec()<CR>
map <Leader>l :call RunLastSpec()<CR>
map <Leader>a :call RunAllSpecs()<CR>

let g:rspec_command = "bundle exec rspec {spec}"
let g:rspec_runner = "os_x_iterm2"

function! LinterStatus() abort
  let l:counts = ale#statusline#Count(bufnr(''))

  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors

  return l:counts.total == 0 ? 'OK' : printf(
        \   '%dW %dE',
        \   all_non_errors,
        \   all_errors
        \)
endfunction

set statusline+=\ %{LinterStatus()}

let g:ale_echo_msg_error_str = 'E'
let g:ale_echo_msg_warning_str = 'W'
let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'

nmap <silent> <C-k> <Plug>(ale_previous_wrap)
nmap <silent> <C-j> <Plug>(ale_next_wrap)

" vim-javascript
augroup vimrc-javascript
  autocmd!
  autocmd FileType javascript set tabstop=4|set shiftwidth=4|set expandtab softtabstop=4
augroup END

" ruby
let g:rubycomplete_buffer_loading = 1
let g:rubycomplete_classes_in_global = 1
let g:rubycomplete_rails = 1

augroup vimrc-ruby
  autocmd!
  autocmd BufNewFile,BufRead *.rb,*.rbw,*.gemspec setlocal filetype=ruby
  autocmd FileType ruby set tabstop=2|set shiftwidth=2|set expandtab softtabstop=2
augroup END

let g:tagbar_type_ruby = {
    \ 'kinds' : [
        \ 'm:modules',
        \ 'c:classes',
        \ 'd:describes',
        \ 'C:contexts',
        \ 'f:methods',
        \ 'F:singleton methods'
    \ ]
\ }

" Ruby refactory
nnoremap <leader>rap  :RAddParameter<cr>
nnoremap <leader>rcpc :RConvertPostConditional<cr>
nnoremap <leader>rel  :RExtractLet<cr>
vnoremap <leader>rec  :RExtractConstant<cr>
vnoremap <leader>relv :RExtractLocalVariable<cr>
nnoremap <leader>rit  :RInlineTemp<cr>
vnoremap <leader>rrlv :RRenameLocalVariable<cr>
vnoremap <leader>rriv :RRenameInstanceVariable<cr>
vnoremap <leader>rem  :RExtractMethod<cr>

"Highlight column for 119 characters.
if exists('+colorcolumn')
  set colorcolumn=+1
else
  au BufWinEnter * let w:m2=matchadd('ErrorMsg', '\%>80.\+', -1)
endif

" session management
nnoremap <leader>so :OpenSession<Space>
nnoremap <leader>ss :SaveSession<Space>
nnoremap <leader>sd :DeleteSession<CR>
nnoremap <leader>sc :CloseSession<CR>

" Quicker window movement
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-h> <C-w>h
nnoremap <C-l> <C-w>l

cnoremap <C-P> <C-R>=expand("%:p:h") . "/" <CR>
nnoremap <silent> <leader>b :Buffers<CR>
nnoremap <silent> <leader>e :FZF -m<CR>

" puts the calller (Thanks to @tenderlove)
nnoremap <leader>wtf oputs "#" * 90<c-m>puts caller<c-m>puts "#" * 90<esc>

" Mapping for debugging in Ruby
nnoremap <leader>db obinding.pry<esc>
nnoremap <leader>bb obyebug<esc>

nnoremap \ :Ack<SPACE>

" Disable 'Entering Ex mode'
map Q <Nop>
map gs <Nop>

" MOVEMENT
nnoremap j gj
nnoremap k gk

" highlight last inserted text
nnoremap gV `[v`]

" Ruby hash syntax conversion
nnoremap <F12> :%s/:\([^ ]*\)\(\s*\)=>/\1:/g<return>

" EASY COPY AND PASTE
" yank to system clipboard
map <leader>y "*y

" paste lines from unnamed register and fix indentation
nmap <leader>p pV`]=
nmap <leader>P PV`]=

" Settings for vim-ditto
nmap <leader>di <Plug>ToggleDitto      " Turn it on and off

nmap =d <Plug>DittoNext                " Jump to the next word
nmap -d <Plug>DittoPrev                " Jump to the previous word
nmap +d <Plug>DittoGood                " Ignore the word under the cursor
nmap _d <Plug>DittoBad                 " Stop ignoring the word under the cursor
nmap ]d <Plug>DittoMore                " Show the next matches
nmap [d <Plug>DittoLess                " Show the previous matches

" expand %% to current directory in command-line mode
cnoremap %% <C-R>=expand('%:h').'/'<cr>

" Index ctags from any project, including those outside Rails
map <Leader>ct :!ctags --tag-relative=yes --extras=+f -Rf.git/tags --exclude=.git --exclude=pkg --exclude=.ext --languages=-javascript,sql<cr><cr>

map <Leader>n :NERDTreeToggle<CR>

map <c-a> ggVG

" format the entire file
nmap <leader>fef ggVG=

" upper/lower word
nmap <leader>u mQviwU`Q
nmap <leader>l mQviwu`Q

" upper/lower first char of word
nmap <leader>U mQgewvU`Q
nmap <leader>L mQgewvu`Q

" find Git merge conflict markers
nmap <silent> <leader>fc <ESC>/\v^[<=>]{7}( .*\|$)<CR>

" Toggle hlsearch with <leader>hs
nmap <leader>hs :set hlsearch! hlsearch?<CR>

" Start interactive EasyAlign in visual mode (e.g. vipga)
xmap ga <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)

" Adjust viewports to the same size
map <Leader>= <C-w>=

map <leader>gf :e <cfile><cr>

" vim-maximizer (Zoom)
noremap <Leader>zw :MaximizerToggle<CR>
vnoremap <Leader>zw :MaximizerToggle<CR>gv
inoremap <Leader>zw <C-o>:MaximizerToggle<CR>

" TagbarToggle
nnoremap <Leader>rt :TagbarToggle<CR>
let g:tagbar_autofocus = 1

" disable cursor keys in normal mode
map <Left>  :echoe "Use h"<cr>
map <Right> :echoe "Use l"<cr>
map <Up>    :echoe "Use k"<cr>
map <Down>  :echoe "Use j"<cr>

" Git Hunks
nmap ]h <Plug>GitGutterNextHunk
nmap [h <Plug>GitGutterPrevHunk
nmap <Leader>hv <Plug>GitGutterPreviewHunk " Preview hunk

"Make shift-insert work like in Xterm
map <S-Insert> <MiddleMouse>
map! <S-Insert> <MiddleMouse>

"Map Control-# to switch tabs
map  <C-0> 0gt
imap <C-0> <Esc>0gt
map  <C-1> 1gt
imap <C-1> <Esc>1gt
map  <C-2> 2gt
imap <C-2> <Esc>2gt
map  <C-3> 3gt
imap <C-3> <Esc>3gt
map  <C-4> 4gt
imap <C-4> <Esc>4gt
map  <C-5> 5gt
imap <C-5> <Esc>5gt
map  <C-6> 6gt
imap <C-6> <Esc>6gt
map  <C-7> 7gt
imap <C-7> <Esc>7gt
map  <C-8> 8gt
imap <C-8> <Esc>8gt
map  <C-9> 9gt
imap <C-9> <Esc>9gt

noremap <F5> :UndotreeToggle<cr>

" In command-line mode, C-a jumps to beginning (to match C-e)
cnoremap <C-a> <Home>

" vim-expand-region
vmap v <Plug>(expand_region_expand)
vmap <C-v> <Plug>(expand_region_shrink)

" To open a new empty buffer
" This replaces :tabnew which I used to bind to this mapping
nmap <leader>T :enew<cr>

" Exit insert mode without using Esc
inoremap jj <Esc>

" Easy edit/open commands
command! EditVim  :edit   ~/.vimrc
command! EditBash :edit   ~/.bashrc

"bind \ (backward slash) to grep shortcut
command! -nargs=+ -complete=file -bar Ag silent! grep! <args>|cwindow|redraw!

function! s:setWrapping()
  set wrap
  set wrapmargin=2
  set textwidth=80
endfunction

if has("autocmd")
  " In Makefiles, use real tabs, not tabs expanded to spaces
  au FileType {make,gitconfig} set noexpandtab

  " Make sure all markdown files have the correct filetype set and setup wrapping
  au BufRead,BufNewFile *.{md,markdown,mdown,mkd,mkdn,txt} setf markdown | call s:setWrapping()

  " Treat JSON files like JavaScript
  au BufNewFile,BufRead *.json setf javascript

  " Better commit message
  au Filetype gitcommit setlocal spell textwidth=72

  " For all text files set 'textwidth' to 80 characters.
  au Filetype text setlocal textwidth=80

  " Enable spellchecking for Markdown
  au FileType markdown setlocal spell

  au FileType javascript,css,ruby,rake,erb nmap <silent> ,; :call cosco#commaOrSemiColon()<CR>
  au FileType javascript,css,ruby,rake,erb inoremap <silent> ,; <ESC>:call cosco#commaOrSemiColon()"<CR>a

  au StdinReadPre * let s:std_in=1

  au FileType markdown,text,tex,gitcommit DittoOn  " Turn on Ditto's autocmds

  au FileType javascript set formatprg=prettier\ --stdin
endif

" FIX CONSTANT SPELLING MISTAKES
iab Acheive    Achieve
iab acheive    achieve
iab Alos       Also
iab alos       also
iab Aslo       Also
iab aslo       also
iab Becuase    Because
iab becuase    because
iab Bianries   Binaries
iab Charcter   Character
iab charcter   character
iab Charcters  Characters
iab charcters  characters
iab Seperate   Separate
iab seperate   separate
iab biding     binding
iab binging    binding
iab biging     binding
iab bindng     binding
iab bindging   binding
iab bindgin    binding
iab gindin     binding
iab bindin     binding
iab bindign    binding
iab attachemnts attachments
iab attachemnt attachment
iab udpate     update

" Local config
"if filereadable($HOME . "/.vimrc.local")
"source ~/.vimrc.local
"endif
